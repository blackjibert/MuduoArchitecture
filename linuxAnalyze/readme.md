## Linux的五种I/O模型

**阻塞、非阻塞、IO多路复用(poll,select,epoll)、信号驱动(sigaction)、异步五种I/O模型。**


### 阻塞

![Alt text](pic/image.png)
- 在此模式中，当应用程序执行I/O操作时，如果数据还没有准备好，应用程序就会被阻塞（挂起），直到数据准备好为止。这期间，应用程序不能做其他事情。

 
 ### 非阻塞
 ![Alt text](pic/image2.png)
- 在此模式中，如果I/O操作的数据还没有准备好，操作会立即返回一个错误，而不是阻塞应用程序。应用程序可以继续执行其他操作，也可以反复尝试该I/O操作。这种模型需要线程轮询来检查I/O操作的就绪状态，以及可能的数据可用性。
- 一组非阻塞的系统调用，例如read()、write()、open()，比如调用read之前，将setsockopt(sockfd)设置为non-blocking，与上面相比，数据未就绪，可以通过轮询，不断返回(一个错误码(例如EAGAIN或EWOULDBLOCK))，通过返回值的判断。数据准备好以后，数据从内核TCP缓冲去拷贝到应用程序的buffer缓冲区，还是要花费应用程序的事件，这是一个**同步**的操作。


### IO多路复用(事件驱动I/O)

![Alt text](pic/image3.png)
- 在此模式中，应用程序可以同时监控多个I/O描述符(比如,socket), 当任何一个I/O描述符准备好数据时, 应用程序就可以对其进行处理。这可以在一个单独的进程或线程中同时处理多个I/O操作, 并且不需要阻塞或轮询。select、poll、epoll都是这种模型的实现。

### 信号驱动
![Alt text](pic/image4.png)
- 在此模型中, 应用程序可以向操作系统注册一个信号处理函数sigaction, 当数据准备好时(当文件描述符主备好),操作系统会发送一个信号, 应用程序可以在接收到信号时读取数据。这种模式避免了阻塞和轮询,但是编程复杂性较高。**文件描述符就是该文件对应的打开文件表中表项的索引值。**

### 异步I/O
![Alt text](pic/image5.png)
- 在此模型中，应用程序发起I/O操作后，可以立即开始做其他事情，当数据准备好时，操作系统会将数据复制到应用程序的缓冲区，并通知应用程序。这种模型的优点是应用程序不需要等待I/O操作的完成，缺点是编程复杂性较高。